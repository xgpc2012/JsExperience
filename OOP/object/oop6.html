<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dynamic Prototype Pattern</title>
</head>
<body>
</body>
<script>
    //它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下）
    //又保持了同时使用构造函数和原型的优点。换句话说，可以通过
    //检查某个应该存在的方法是否有效，来决定是否需要初始化原型
    function Person(name, age, job) {
        //属性
        this.name = name;
        this.age = age;
        this.job = job;
        //方法
        if (typeof this.sayName != "function") {
            Person.prototype.sayName = function () {
                console.log(this.name);
            };
        }
    }
    var friend = new Person("Nicholas", 29, "Software Engineer");
    friend.sayName();
    //这里只在 sayName() 方法不存在的情况下，才会将它添加到原型中。
    //这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。
    //这里对原型所做的修改，能够立即在所有实例中得到反映。
    //使用动态原型模式时，不能使用对象字面量重写原型。
    //如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。
</script>
</html>
